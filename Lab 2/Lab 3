✅ Lab: Resource Monitoring and Logging System Using Python Decorators, Generators, and Context Managers
📘 Problem Statement:
You are a Python Developer at a TechOps company. Your task is to develop a modular and efficient system to monitor, log, and manage operations on system resources or services (like API calls, file operations, or DB queries). The system should log processing time, memory usage, and control resources using Python's advanced programming features.

🧱 Objectives:
Use decorators to log execution time and memory usage

Use generators to simulate streaming/log processing

Use context managers for safe resource management (like files, DB connections)

Make reusable, clean, and production-grade utility functions

🛠️ Tasks to Implement:
🔹 1. Create Custom Decorators
@log_execution_time → Logs function run-time

@log_memory_usage → Monitors memory footprint (using tracemalloc or psutil)

🔹 2. Implement Generators for Log Streaming
Simulate logs with a generator that yields log lines (simulate real-time streaming)

Add filtering or transformation to log stream (e.g., filter only errors)

🔹 3. Manage Resources using Context Managers
Create a custom context manager for:

File operations

Database connections (use mock functions)

API session handling

🔹 4. Simulate Real-World Workflow
Define dummy resource-consuming functions (API calls, data write)

Wrap them with decorators and context managers

Log output stream using generators

🔄 Advanced Functional Design Hints:
Use yield for memory-efficient log streaming

Use @wraps in decorators to preserve metadata

Use with statements for managing resources

📊 Expected Output:
Logs with timestamps and memory stats

Simulated real-time monitoring with filters

Clean execution summary

Properly managed file/resources even on error

🧪 Bonus (For More Advanced Users):
Create a Decorator Factory to configure thresholds for logging

Chain multiple decorators dynamically

Use functools.partial or contextlib.contextmanager for elegant implementations

✅ Concepts Covered:
Decorators (basic, parameterized, and chaining)

Generators & memory-efficient loops

Context managers (with, __enter__, __exit__)

Real-time simulation and abstraction

